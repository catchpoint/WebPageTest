import{HeapSnapshotModel as e}from"../heap_snapshot_model/heap_snapshot_model.js";import{UIString as t}from"../common/common.js";import{ls as s,ArrayUtilities as n}from"../platform/platform.js";import{TextUtils as i}from"../text_utils/text_utils.js";class o{constructor(e,t){this._strings=e.strings,this._liveObjectStats=t,this._nextNodeId=1,this._functionInfos=[],this._idToNode={},this._idToTopDownNode={},this._collapsedTopNodeIdToFunctionInfo={},this._traceTops=[],this._buildFunctionAllocationInfos(e),this._traceTree=this._buildAllocationTree(e,t)}_buildFunctionAllocationInfos(e){const t=this._strings,s=e.snapshot.meta.trace_function_info_fields,n=s.indexOf("name"),i=s.indexOf("script_name"),o=s.indexOf("script_id"),r=s.indexOf("line"),d=s.indexOf("column"),h=s.length,l=e.trace_function_infos,_=l.length,c=this._functionInfos=new Array(_/h);let u=0;for(let e=0;e<_;e+=h)c[u++]=new a(t[l[e+n]],t[l[e+i]],l[e+o],l[e+r],l[e+d])}_buildAllocationTree(e,t){const s=e.trace_tree,n=this._functionInfos,i=this._idToTopDownNode,o=e.snapshot.meta.trace_node_fields,d=o.indexOf("id"),a=o.indexOf("function_info_index"),h=o.indexOf("count"),l=o.indexOf("size"),_=o.indexOf("children"),c=o.length;return function e(s,o,u){const f=n[s[o+a]],p=s[o+d],g=t[p],m=g?g.count:0,x=g?g.size:0,I=new r(p,f,s[o+h],s[o+l],m,x,u);i[p]=I,f.addTraceTopNode(I);const N=s[o+_];for(let t=0;t<N.length;t+=c)I.children.push(e(N,t,I));return I}(s,0,null)}serializeTraceTops(){if(this._traceTops)return this._traceTops;const e=this._traceTops=[],t=this._functionInfos;for(let s=0;s<t.length;s++){const n=t[s];if(0===n.totalCount)continue;const i=this._nextNodeId++,o=0===s;e.push(this._serializeNode(i,n,n.totalCount,n.totalSize,n.totalLiveCount,n.totalLiveSize,!o)),this._collapsedTopNodeIdToFunctionInfo[i]=n}return e.sort((function(e,t){return t.size-e.size})),e}serializeCallers(t){let s=this._ensureBottomUpNode(t);const n=[];for(;1===s.callers().length;)s=s.callers()[0],n.push(this._serializeCaller(s));const i=[],o=s.callers();for(let e=0;e<o.length;e++)i.push(this._serializeCaller(o[e]));return new e.AllocationNodeCallers(n,i)}serializeAllocationStack(t){let s=this._idToTopDownNode[t];const n=[];for(;s;){const t=s.functionInfo;n.push(new e.AllocationStackFrame(t.functionName,t.scriptName,t.scriptId,t.line,t.column)),s=s.parent}return n}traceIds(e){return this._ensureBottomUpNode(e).traceTopIds}_ensureBottomUpNode(e){let t=this._idToNode[e];if(!t){t=this._collapsedTopNodeIdToFunctionInfo[e].bottomUpRoot(),delete this._collapsedTopNodeIdToFunctionInfo[e],this._idToNode[e]=t}return t}_serializeCaller(e){const t=this._nextNodeId++;return this._idToNode[t]=e,this._serializeNode(t,e.functionInfo,e.allocationCount,e.allocationSize,e.liveCount,e.liveSize,e.hasCallers())}_serializeNode(t,s,n,i,o,r,d){return new e.SerializedAllocationNode(t,s.functionName,s.scriptName,s.scriptId,s.line,s.column,n,i,o,r,d)}}class r{constructor(e,t,s,n,i,o,r){this.id=e,this.functionInfo=t,this.allocationCount=s,this.allocationSize=n,this.liveCount=i,this.liveSize=o,this.parent=r,this.children=[]}}class d{constructor(e){this.functionInfo=e,this.allocationCount=0,this.allocationSize=0,this.liveCount=0,this.liveSize=0,this.traceTopIds=[],this._callers=[]}addCaller(e){const t=e.functionInfo;let s;for(let e=0;e<this._callers.length;e++){const n=this._callers[e];if(n.functionInfo===t){s=n;break}}return s||(s=new d(t),this._callers.push(s)),s}callers(){return this._callers}hasCallers(){return this._callers.length>0}}class a{constructor(e,t,s,n,i){this.functionName=e,this.scriptName=t,this.scriptId=s,this.line=n,this.column=i,this.totalCount=0,this.totalSize=0,this.totalLiveCount=0,this.totalLiveSize=0,this._traceTops=[]}addTraceTopNode(e){0!==e.allocationCount&&(this._traceTops.push(e),this.totalCount+=e.allocationCount,this.totalSize+=e.allocationSize,this.totalLiveCount+=e.liveCount,this.totalLiveSize+=e.liveSize)}bottomUpRoot(){return this._traceTops.length?(this._bottomUpTree||this._buildAllocationTraceTree(),this._bottomUpTree):null}_buildAllocationTraceTree(){this._bottomUpTree=new d(this);for(let e=0;e<this._traceTops.length;e++){let t=this._traceTops[e],s=this._bottomUpTree;const n=t.allocationCount,i=t.allocationSize,o=t.liveCount,r=t.liveSize,d=t.id;for(;s.allocationCount+=n,s.allocationSize+=i,s.liveCount+=o,s.liveSize+=r,s.traceTopIds.push(d),t=t.parent,null!==t;)s=s.addCaller(t)}}}var h=Object.freeze({__proto__:null,AllocationProfile:o,TopDownAllocationNode:r,BottomUpAllocationNode:d,FunctionAllocationInfo:a});class l{constructor(e,t){this._snapshot=e,this._edges=e.containmentEdges,this.edgeIndex=t||0}clone(){return new l(this._snapshot,this.edgeIndex)}hasStringName(){throw new Error("Not implemented")}name(){throw new Error("Not implemented")}node(){return this._snapshot.createNode(this.nodeIndex())}nodeIndex(){if(void 0===this._snapshot._edgeToNodeOffset)throw new Error("edgeToNodeOffset is undefined");return this._edges[this.edgeIndex+this._snapshot._edgeToNodeOffset]}toString(){return"HeapSnapshotEdge: "+this.name()}type(){return this._snapshot._edgeTypes[this.rawType()]}itemIndex(){return this.edgeIndex}serialize(){return new e.Edge(this.name(),this.node().serialize(),this.type(),this.edgeIndex)}rawType(){if(void 0===this._snapshot._edgeTypeOffset)throw new Error("edgeTypeOffset is undefined");return this._edges[this.edgeIndex+this._snapshot._edgeTypeOffset]}isInvisible(){throw new Error("Not implemented")}isWeak(){throw new Error("Not implemented")}}class _{constructor(e){this._node=e.createNode()}itemForIndex(e){return this._node.nodeIndex=e,this._node}}class c{constructor(e){this._edge=e.createEdge(0)}itemForIndex(e){return this._edge.edgeIndex=e,this._edge}}class u{constructor(e){this._retainerEdge=e.createRetainingEdge(0)}itemForIndex(e){return this._retainerEdge.setRetainerIndex(e),this._retainerEdge}}class f{constructor(e){this._sourceNode=e,this.edge=e._snapshot.createEdge(e.edgeIndexesStart())}hasNext(){return this.edge.edgeIndex<this._sourceNode.edgeIndexesEnd()}item(){return this.edge}next(){if(void 0===this.edge._snapshot._edgeFieldsCount)throw new Error("edgeFieldsCount is undefined");this.edge.edgeIndex+=this.edge._snapshot._edgeFieldsCount}}class p{constructor(e,t){this._snapshot=e,this._retainerIndex,this._globalEdgeIndex,this.setRetainerIndex(t)}clone(){return new p(this._snapshot,this.retainerIndex())}hasStringName(){return this._edge().hasStringName()}name(){return this._edge().name()}node(){return this._node()}nodeIndex(){if(void 0===this._retainingNodeIndex)throw new Error("retainingNodeIndex is undefined");return this._retainingNodeIndex}retainerIndex(){return this._retainerIndex}setRetainerIndex(e){if(e!==this._retainerIndex){if(!this._snapshot._retainingEdges||!this._snapshot._retainingNodes)throw new Error("Snapshot does not contain retaining edges or retaining nodes");this._retainerIndex=e,this._globalEdgeIndex=this._snapshot._retainingEdges[e],this._retainingNodeIndex=this._snapshot._retainingNodes[e],this._edgeInstance=null,this._nodeInstance=null}}set edgeIndex(e){this.setRetainerIndex(e)}_node(){return this._nodeInstance||(this._nodeInstance=this._snapshot.createNode(this._retainingNodeIndex)),this._nodeInstance}_edge(){return this._edgeInstance||(this._edgeInstance=this._snapshot.createEdge(this._globalEdgeIndex)),this._edgeInstance}toString(){return this._edge().toString()}itemIndex(){return this._retainerIndex}serialize(){return new e.Edge(this.name(),this.node().serialize(),this.type(),this._globalEdgeIndex)}type(){return this._edge().type()}}class g{constructor(e){const t=e._snapshot,s=e.ordinal();if(!t._firstRetainerIndex)throw new Error("Snapshot does not contain firstRetainerIndex");const n=t._firstRetainerIndex[s];this._retainersEnd=t._firstRetainerIndex[s+1],this.retainer=t.createRetainingEdge(n)}hasNext(){return this.retainer.retainerIndex()<this._retainersEnd}item(){return this.retainer}next(){this.retainer.setRetainerIndex(this.retainer.retainerIndex()+1)}}class m{constructor(e,t){this._snapshot=e,this.nodeIndex=t||0}distance(){return this._snapshot._nodeDistances[this.nodeIndex/this._snapshot._nodeFieldCount]}className(){throw new Error("Not implemented")}classIndex(){throw new Error("Not implemented")}dominatorIndex(){const e=this._snapshot._nodeFieldCount;return this._snapshot._dominatorsTree[this.nodeIndex/this._snapshot._nodeFieldCount]*e}edges(){return new f(this)}edgesCount(){return(this.edgeIndexesEnd()-this.edgeIndexesStart())/this._snapshot._edgeFieldsCount}id(){throw new Error("Not implemented")}rawName(){throw new Error("Not implemented")}isRoot(){return this.nodeIndex===this._snapshot._rootNodeIndex}isUserRoot(){throw new Error("Not implemented")}isHidden(){throw new Error("Not implemented")}isArray(){throw new Error("Not implemented")}isDocumentDOMTreesRoot(){throw new Error("Not implemented")}name(){return this._snapshot.strings[this._name()]}retainedSize(){return this._snapshot._retainedSizes[this.ordinal()]}retainers(){return new g(this)}retainersCount(){const e=this._snapshot,t=this.ordinal();return e._firstRetainerIndex[t+1]-e._firstRetainerIndex[t]}selfSize(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeSelfSizeOffset]}type(){return this._snapshot._nodeTypes[this.rawType()]}traceNodeId(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeTraceNodeIdOffset]}itemIndex(){return this.nodeIndex}serialize(){return new e.Node(this.id(),this.name(),this.distance(),this.nodeIndex,this.retainedSize(),this.selfSize(),this.type())}_name(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeNameOffset]}edgeIndexesStart(){return this._snapshot._firstEdgeIndexes[this.ordinal()]}edgeIndexesEnd(){return this._snapshot._firstEdgeIndexes[this.ordinal()+1]}ordinal(){return this.nodeIndex/this._snapshot._nodeFieldCount}_nextNodeIndex(){return this.nodeIndex+this._snapshot._nodeFieldCount}rawType(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeTypeOffset]}}class x{constructor(e){this.node=e,this._nodesLength=e._snapshot.nodes.length}hasNext(){return this.node.nodeIndex<this._nodesLength}item(){return this.node}next(){this.node.nodeIndex=this.node._nextNodeIndex()}}class I{constructor(e,t){this._itemProvider=e,this._indexes=t,this._position=0}hasNext(){return this._position<this._indexes.length}item(){const e=this._indexes[this._position];return this._itemProvider.itemForIndex(e)}next(){++this._position}}class N{constructor(e,t){this._iterator=e,this._filter=t,this._skipFilteredItems()}hasNext(){return this._iterator.hasNext()}item(){return this._iterator.item()}next(){this._iterator.next(),this._skipFilteredItems()}_skipFilteredItems(){for(;this._iterator.hasNext()&&this._filter&&!this._filter(this._iterator.item());)this._iterator.next()}}class y{constructor(e){this._dispatcher=e}updateStatus(e){this._sendUpdateEvent(t.serializeUIString(e))}updateProgress(e,s,n){const i=(100*(n?s/n:0)).toFixed(0);this._sendUpdateEvent(t.serializeUIString(e,[i]))}reportProblem(t){this._dispatcher&&this._dispatcher.sendEvent(e.HeapSnapshotProgressEvent.BrokenSnapshot,t)}_sendUpdateEvent(t){this._dispatcher&&this._dispatcher.sendEvent(e.HeapSnapshotProgressEvent.Update,t)}}class S{constructor(e){this._errors=[e]}addError(e){this._errors.length>100||this._errors.push(e)}toString(){return this._errors.join("\n  ")}}const w={Unknown:0,Attached:1,Detached:2};Object.freeze(w);class T{constructor(e,t){this.nodes=e.nodes,this.containmentEdges=e.edges,this._metaNode=e.snapshot.meta,this._rawSamples=e.samples,this._samples=null,this.strings=e.strings,this._locations=e.locations,this._progress=t,this._noDistance=-5,this._rootNodeIndex=0,e.snapshot.root_index&&(this._rootNodeIndex=e.snapshot.root_index),this._snapshotDiffs={},this._aggregatesForDiff,this._aggregates={},this._aggregatesSortedFlags={},this._profile=e,this._nodeTypeOffset,this._nodeNameOffset,this._nodeIdOffset,this._nodeSelfSizeOffset,this._nodeEdgeCountOffset,this._nodeTraceNodeIdOffset,this._nodeFieldCount,this._nodeTypes,this._nodeArrayType,this._nodeHiddenType,this._nodeObjectType,this._nodeNativeType,this._nodeConsStringType,this._nodeSlicedStringType,this._nodeCodeType,this._nodeSyntheticType,this._edgeFieldsCount,this._edgeTypeOffset,this._edgeNameOffset,this._edgeToNodeOffset,this._edgeTypes,this._edgeElementType,this._edgeHiddenType,this._edgeInternalType,this._edgeShortcutType,this._edgeWeakType,this._edgeInvisibleType,this._locationIndexOffset,this._locationScriptIdOffset,this._locationLineOffset,this._locationColumnOffset,this._locationFieldCount,this.nodeCount,this._edgeCount,this._retainedSizes,this._firstEdgeIndexes,this._retainingNodes,this._retainingEdges,this._firstRetainerIndex,this._nodeDistances,this._firstDominatedNodeIndex,this._dominatedNodes,this._dominatorsTree,this._allocationProfile,this._nodeDetachednessOffset,this._locationMap,this._lazyStringCache}initialize(){const e=this._metaNode;this._nodeTypeOffset=e.node_fields.indexOf("type"),this._nodeNameOffset=e.node_fields.indexOf("name"),this._nodeIdOffset=e.node_fields.indexOf("id"),this._nodeSelfSizeOffset=e.node_fields.indexOf("self_size"),this._nodeEdgeCountOffset=e.node_fields.indexOf("edge_count"),this._nodeTraceNodeIdOffset=e.node_fields.indexOf("trace_node_id"),this._nodeDetachednessOffset=e.node_fields.indexOf("detachedness"),this._nodeFieldCount=e.node_fields.length,this._nodeTypes=e.node_types[this._nodeTypeOffset],this._nodeArrayType=this._nodeTypes.indexOf("array"),this._nodeHiddenType=this._nodeTypes.indexOf("hidden"),this._nodeObjectType=this._nodeTypes.indexOf("object"),this._nodeNativeType=this._nodeTypes.indexOf("native"),this._nodeConsStringType=this._nodeTypes.indexOf("concatenated string"),this._nodeSlicedStringType=this._nodeTypes.indexOf("sliced string"),this._nodeCodeType=this._nodeTypes.indexOf("code"),this._nodeSyntheticType=this._nodeTypes.indexOf("synthetic"),this._edgeFieldsCount=e.edge_fields.length,this._edgeTypeOffset=e.edge_fields.indexOf("type"),this._edgeNameOffset=e.edge_fields.indexOf("name_or_index"),this._edgeToNodeOffset=e.edge_fields.indexOf("to_node"),this._edgeTypes=e.edge_types[this._edgeTypeOffset],this._edgeTypes.push("invisible"),this._edgeElementType=this._edgeTypes.indexOf("element"),this._edgeHiddenType=this._edgeTypes.indexOf("hidden"),this._edgeInternalType=this._edgeTypes.indexOf("internal"),this._edgeShortcutType=this._edgeTypes.indexOf("shortcut"),this._edgeWeakType=this._edgeTypes.indexOf("weak"),this._edgeInvisibleType=this._edgeTypes.indexOf("invisible");const t=e.location_fields||[];this._locationIndexOffset=t.indexOf("object_index"),this._locationScriptIdOffset=t.indexOf("script_id"),this._locationLineOffset=t.indexOf("line"),this._locationColumnOffset=t.indexOf("column"),this._locationFieldCount=t.length,this.nodeCount=this.nodes.length/this._nodeFieldCount,this._edgeCount=this.containmentEdges.length/this._edgeFieldsCount,this._retainedSizes=new Float64Array(this.nodeCount),this._firstEdgeIndexes=new Uint32Array(this.nodeCount+1),this._retainingNodes=new Uint32Array(this._edgeCount),this._retainingEdges=new Uint32Array(this._edgeCount),this._firstRetainerIndex=new Uint32Array(this.nodeCount+1),this._nodeDistances=new Int32Array(this.nodeCount),this._firstDominatedNodeIndex=new Uint32Array(this.nodeCount+1),this._dominatedNodes=new Uint32Array(this.nodeCount-1),this._progress.updateStatus(s`Building edge indexes…`),this._buildEdgeIndexes(),this._progress.updateStatus(s`Building retainers…`),this._buildRetainers(),this._progress.updateStatus(s`Propagating DOM state…`),this._propagateDOMState(),this._progress.updateStatus(s`Calculating node flags…`),this.calculateFlags(),this._progress.updateStatus(s`Calculating distances…`),this.calculateDistances(),this._progress.updateStatus(s`Building postorder index…`);const n=this._buildPostOrderIndex();if(this._progress.updateStatus(s`Building dominator tree…`),this._dominatorsTree=this._buildDominatorTree(n.postOrderIndex2NodeOrdinal,n.nodeOrdinal2PostOrderIndex),this._progress.updateStatus(s`Calculating retained sizes…`),this._calculateRetainedSizes(n.postOrderIndex2NodeOrdinal),this._progress.updateStatus(s`Building dominated nodes…`),this._buildDominatedNodes(),this._progress.updateStatus(s`Calculating statistics…`),this.calculateStatistics(),this._progress.updateStatus(s`Calculating samples…`),this._buildSamples(),this._progress.updateStatus(s`Building locations…`),this._buildLocationMap(),this._progress.updateStatus(s`Finished processing.`),this._profile.snapshot.trace_function_count){this._progress.updateStatus(s`Building allocation statistics…`);const e=this.nodes.length,t=this._nodeFieldCount,n=this.rootNode(),i={};for(let s=0;s<e;s+=t){n.nodeIndex=s;const e=n.traceNodeId();let t=i[e];t||(i[e]=t={count:0,size:0,ids:[]}),t.count++,t.size+=n.selfSize(),t.ids.push(n.id())}this._allocationProfile=new o(this._profile,i),this._progress.updateStatus(s`Done`)}}_buildEdgeIndexes(){const e=this.nodes,t=this.nodeCount,s=this._firstEdgeIndexes,n=this._nodeFieldCount,i=this._edgeFieldsCount,o=this._nodeEdgeCountOffset;s[t]=this.containmentEdges.length;for(let r=0,d=0;r<t;++r)s[r]=d,d+=e[r*n+o]*i}_buildRetainers(){const e=this._retainingNodes,t=this._retainingEdges,s=this._firstRetainerIndex,n=this.containmentEdges,i=this._edgeFieldsCount,o=this._nodeFieldCount,r=this._edgeToNodeOffset,d=this._firstEdgeIndexes,a=this.nodeCount;for(let e=r,t=n.length;e<t;e+=i){const t=n[e];if(t%o)throw new Error("Invalid toNodeIndex "+t);++s[t/o]}for(let t=0,n=0;t<a;t++){const i=s[t];s[t]=n,e[n]=i,n+=i}s[a]=e.length;let h=d[0];for(let l=0;l<a;++l){const a=h;h=d[l+1];const _=l*o;for(let d=a;d<h;d+=i){const i=n[d+r];if(i%o)throw new Error("Invalid toNodeIndex "+i);const a=s[i/o],h=a+--e[a];e[h]=_,t[h]=d}}}createNode(e){throw new Error("Not implemented")}createEdge(e){throw new Error("Not implemented")}createRetainingEdge(e){throw new Error("Not implemented")}_allNodes(){return new x(this.rootNode())}rootNode(){return this.createNode(this._rootNodeIndex)}get rootNodeIndex(){return this._rootNodeIndex}get totalSize(){return this.rootNode().retainedSize()}_getDominatedIndex(e){if(e%this._nodeFieldCount)throw new Error("Invalid nodeIndex: "+e);return this._firstDominatedNodeIndex[e/this._nodeFieldCount]}_createFilter(e){const t=e.minNodeId,s=e.maxNodeId,n=e.allocationNodeId;let i;if("number"==typeof n){if(i=this._createAllocationStackFilter(n),!i)throw new Error("Unable to create filter");i.key="AllocationNodeId: "+n}else"number"==typeof t&&"number"==typeof s&&(i=this._createNodeIdFilter(t,s),i.key="NodeIdRange: "+t+".."+s);return i}search(e,t){const s=e.query;const n=e.isRegex?new RegExp(s):createPlainTextSearchRegex(s,"i");const i=e.isRegex||!e.caseSensitive?function(e,t,s){return n.test(t)&&e.add(s),e}:function(e,t,n){return-1!==t.indexOf(s)&&e.add(n),e},o=this.strings.reduce(i,new Set);if(!o.size)return[];const r=this._createFilter(t),d=[],a=this.nodes.length,h=this.nodes,l=this._nodeNameOffset,_=this._nodeIdOffset,c=this._nodeFieldCount,u=this.rootNode();for(let e=0;e<a;e+=c)u.nodeIndex=e,r&&!r(u)||o.has(h[e+l])&&d.push(h[e+_]);return d}aggregatesWithFilter(e){const t=this._createFilter(e),s=t?t.key:"allObjects";return this.aggregates(!1,s,t)}_createNodeIdFilter(e,t){return function(s){const n=s.id();return n>e&&n<=t}}_createAllocationStackFilter(e){if(!this._allocationProfile)throw new Error("No Allocation Profile provided");const t=this._allocationProfile.traceIds(e);if(!t.length)return;const s={};for(let e=0;e<t.length;e++)s[t[e]]=!0;return function(e){return Boolean(s[e.traceNodeId()])}}aggregates(e,t,s){const n=this._buildAggregates(s);let i;return t&&this._aggregates[t]?i=this._aggregates[t]:(this._calculateClassesRetainedSize(n.aggregatesByClassIndex,s),i=n.aggregatesByClassName,t&&(this._aggregates[t]=i)),!e||t&&this._aggregatesSortedFlags[t]||(this._sortAggregateIndexes(n.aggregatesByClassName),t&&(this._aggregatesSortedFlags[t]=e)),i}allocationTracesTops(){return this._allocationProfile.serializeTraceTops()}allocationNodeCallers(e){return this._allocationProfile.serializeCallers(e)}allocationStack(e){const t=this.createNode(e).traceNodeId();return t?this._allocationProfile.serializeAllocationStack(t):null}aggregatesForDiff(){if(this._aggregatesForDiff)return this._aggregatesForDiff;const e=this.aggregates(!0,"allObjects");this._aggregatesForDiff={};const t=this.createNode();for(const s in e){const n=e[s].idxs,i=new Array(n.length),o=new Array(n.length);for(let e=0;e<n.length;e++)t.nodeIndex=n[e],i[e]=t.id(),o[e]=t.selfSize();this._aggregatesForDiff[s]={indexes:n,ids:i,selfSizes:o}}return this._aggregatesForDiff}isUserRoot(e){return!0}calculateDistances(t){const s=this.nodeCount,n=this._nodeDistances,i=this._noDistance;for(let e=0;e<s;++e)n[e]=i;const o=new Uint32Array(this.nodeCount);let r=0;for(let e=this.rootNode().edges();e.hasNext();e.next()){const t=e.edge.node();this.isUserRoot(t)&&(n[t.ordinal()]=1,o[r++]=t.nodeIndex)}this._bfs(o,r,n,t),n[this.rootNode().ordinal()]=r>0?e.baseSystemDistance:0,o[0]=this.rootNode().nodeIndex,r=1,this._bfs(o,r,n,t)}_bfs(e,t,s,n){const i=this._edgeFieldsCount,o=this._nodeFieldCount,r=this.containmentEdges,d=this._firstEdgeIndexes,a=this._edgeToNodeOffset,h=this._edgeTypeOffset,l=this.nodeCount,_=this._edgeWeakType,c=this._noDistance;let u=0;const f=this.createEdge(0),p=this.createNode(0);for(;u<t;){const l=e[u++],g=l/o,m=s[g]+1,x=d[g],I=d[g+1];p.nodeIndex=l;for(let d=x;d<I;d+=i){if(r[d+h]===_)continue;const i=r[d+a],l=i/o;s[l]===c&&(f.edgeIndex=d,n&&!n(p,f)||(s[l]=m,e[t++]=i))}}if(t>l)throw new Error("BFS failed. Nodes to visit ("+t+") is more than nodes count ("+l+")")}_buildAggregates(e){const t={},s={},n=[],i=this.nodes,o=i.length,r=this._nodeNativeType,d=this._nodeFieldCount,a=this._nodeSelfSizeOffset,h=this._nodeTypeOffset,l=this.rootNode(),_=this._nodeDistances;for(let c=0;c<o;c+=d){if(l.nodeIndex=c,e&&!e(l))continue;const o=i[c+a];if(!o&&i[c+h]!==r)continue;const u=l.classIndex(),f=_[c/d];if(u in t){const e=t[u];if(!e)continue;e.distance=Math.min(e.distance,f),++e.count,e.self+=o,e.idxs.push(c)}else{const e=l.type(),i={count:1,distance:f,self:o,maxRet:0,type:e,name:"object"===e||"native"===e?l.name():null,idxs:[c]};t[u]=i,n.push(u),s[l.className()]=i}}for(let e=0,s=n.length;e<s;++e){const s=t[n[e]];s&&(s.idxs=s.idxs.slice())}return{aggregatesByClassName:s,aggregatesByClassIndex:t}}_calculateClassesRetainedSize(e,t){const s=this._rootNodeIndex,n=this.createNode(s),i=[s],o=[-1],r=[],d=new Map,a=this._nodeFieldCount,h=this._nodeTypeOffset,l=this._nodeNativeType,_=this._dominatedNodes,c=this.nodes,u=this._firstDominatedNodeIndex;for(;i.length;){const s=i.pop();n.nodeIndex=s;let f=n.classIndex();const p=Boolean(d.get(f)),g=s/a,m=u[g],x=u[g+1];p||t&&!t(n)||!n.selfSize()&&c[s+h]!==l||(e[f].maxRet+=n.retainedSize(),m!==x&&(d.set(f,!0),o.push(i.length),r.push(f)));for(let e=m;e<x;e++)i.push(_[e]);const I=i.length;for(;o[o.length-1]===I;)o.pop(),f=r.pop(),d.set(f,!1)}}_sortAggregateIndexes(e){const t=this.createNode(),s=this.createNode();for(const n in e)e[n].idxs.sort(((e,n)=>(t.nodeIndex=e,s.nodeIndex=n,t.id()<s.id()?-1:1)))}_isEssentialEdge(e,t){return t!==this._edgeWeakType&&(t!==this._edgeShortcutType||e===this._rootNodeIndex)}_buildPostOrderIndex(){const e=this._nodeFieldCount,t=this.nodeCount,s=this._rootNodeIndex/e,n=this._edgeFieldsCount,i=this._edgeTypeOffset,o=this._edgeToNodeOffset,r=this._firstEdgeIndexes,d=this.containmentEdges,a=this.userObjectsMapAndFlag(),h=a?a.map:null,l=a?a.flag:0,_=new Uint32Array(t),c=new Uint32Array(t),u=new Uint32Array(t),f=new Uint32Array(t),p=new Uint8Array(t);let g=0,m=0;_[0]=s,c[0]=r[s],p[s]=1;let x=0;for(;;){for(++x;m>=0;){const t=_[m],a=c[m];if(a<r[t+1]){c[m]+=n;const u=d[a+i];if(!this._isEssentialEdge(t*e,u))continue;const f=d[a+o]/e;if(p[f])continue;const g=!h||h[t]&l,x=!h||h[f]&l;if(t!==s&&x&&!g)continue;++m,_[m]=f,c[m]=r[f],p[f]=1}else f[t]=g,u[g++]=t,--m}if(g===t||x>1)break;const a=new S(`Heap snapshot: ${t-g} nodes are unreachable from the root. Following nodes have only weak retainers:`),I=this.rootNode();--g,m=0,_[0]=s,c[0]=r[s+1];for(let s=0;s<t;++s){if(p[s]||!this._hasOnlyWeakRetainers(s))continue;_[++m]=s,c[m]=r[s],p[s]=1,I.nodeIndex=s*e;const t=[];for(let e=I.retainers();e.hasNext();e.next())t.push(`${e.item().node().name()}@${e.item().node().id()}.${e.item().name()}`);a.addError(`${I.name()} @${I.id()}  weak retainers: ${t.join(", ")}`)}console.warn(a.toString())}if(g!==t){const n=new S("Still found "+(t-g)+" unreachable nodes in heap snapshot:"),i=this.rootNode();--g;for(let s=0;s<t;++s)p[s]||(i.nodeIndex=s*e,n.addError(i.name()+" @"+i.id()),f[s]=g,u[g++]=s);f[s]=g,u[g++]=s,console.warn(n.toString())}return{postOrderIndex2NodeOrdinal:u,nodeOrdinal2PostOrderIndex:f}}_hasOnlyWeakRetainers(e){const t=this._edgeTypeOffset,s=this._edgeWeakType,n=this._edgeShortcutType,i=this.containmentEdges,o=this._retainingEdges,r=this._firstRetainerIndex[e],d=this._firstRetainerIndex[e+1];for(let e=r;e<d;++e){const r=i[o[e]+t];if(r!==s&&r!==n)return!1}return!0}_buildDominatorTree(e,t){const s=this._nodeFieldCount,n=this._firstRetainerIndex,i=this._retainingNodes,o=this._retainingEdges,r=this._edgeFieldsCount,d=this._edgeTypeOffset,a=this._edgeToNodeOffset,h=this._firstEdgeIndexes,l=this.containmentEdges,_=this._rootNodeIndex,c=this.userObjectsMapAndFlag(),u=c?c.map:null,f=c?c.flag:0,p=e.length,g=p-1,m=p,x=new Uint32Array(p);for(let e=0;e<g;++e)x[e]=m;x[g]=g;const I=new Uint8Array(p);let N;{N=this._rootNodeIndex/s;const e=h[N+1];for(let n=h[N];n<e;n+=r){const e=l[n+d];if(!this._isEssentialEdge(this._rootNodeIndex,e))continue;I[t[l[n+a]/s]]=1}}let y=!0;for(;y;){y=!1;for(let c=g-1;c>=0;--c){if(0===I[c])continue;if(I[c]=0,x[c]===g)continue;N=e[c];const p=!u||u[N]&f;let S=m;const w=n[N],T=n[N+1];let O=!0;for(let e=w;e<T;++e){const n=l[o[e]+d],r=i[e];if(!this._isEssentialEdge(r,n))continue;O=!1;const a=r/s,h=!u||u[a]&f;if(r!==_&&p&&!h)continue;let c=t[a];if(x[c]!==m){if(S===m)S=c;else for(;c!==S;){for(;c<S;)c=x[c];for(;S<c;)S=x[S]}if(S===g)break}}if(O&&(S=g),S!==m&&x[c]!==S){x[c]=S,y=!0,N=e[c];const n=h[N]+a,i=h[N+1];for(let e=n;e<i;e+=r){I[t[l[e]/s]]=1}}}}const S=new Uint32Array(p);for(let t=0,s=x.length;t<s;++t)N=e[t],S[N]=e[x[t]];return S}_calculateRetainedSizes(e){const t=this.nodeCount,s=this.nodes,n=this._nodeSelfSizeOffset,i=this._nodeFieldCount,o=this._dominatorsTree,r=this._retainedSizes;for(let e=0;e<t;++e)r[e]=s[e*i+n];for(let s=0;s<t-1;++s){const t=e[s];r[o[t]]+=r[t]}}_buildDominatedNodes(){const e=this._firstDominatedNodeIndex,t=this._dominatedNodes,s=this._nodeFieldCount,n=this._dominatorsTree;let i=0,o=this.nodeCount;const r=this._rootNodeIndex/s;if(r===i)i=1;else{if(r!==o-1)throw new Error("Root node is expected to be either first or last");o-=1}for(let t=i;t<o;++t)++e[n[t]];let d=0;for(let s=0,n=this.nodeCount;s<n;++s){const n=t[d]=e[s];e[s]=d,d+=n}e[this.nodeCount]=t.length;for(let r=i;r<o;++r){let i=e[n[r]];i+=--t[i],t[i]=r*s}}_iterateFilteredChildren(e,t,s){const n=this._firstEdgeIndexes[e],i=this._firstEdgeIndexes[e+1];for(let e=n;e<i;e+=this._edgeFieldsCount){const n=this.containmentEdges[e+this._edgeToNodeOffset]/this._nodeFieldCount;t(this.containmentEdges[e+this._edgeTypeOffset])&&s(n)}}_addString(e){return this.strings.push(e),this.strings.length-1}_propagateDOMState(){if(-1===this._nodeDetachednessOffset)return;console.time("propagateDOMState");const e=new Uint8Array(this.nodeCount),t=[],s=[],n=new Map,i=function(i,o,r){if(e[o])return;const d=o*i._nodeFieldCount;i.nodes[d+i._nodeTypeOffset]===i._nodeNativeType?(i.nodes[d+i._nodeDetachednessOffset]=r,r===w.Attached?t.push(o):r===w.Detached&&(!function(e,t){const s=e.nodes[t+e._nodeNameOffset];let i=n.get(s);void 0===i&&(i=e._addString("Detached "+e.strings[s]),n.set(s,i)),e.nodes[t+e._nodeNameOffset]=i}(i,d),s.push(o)),e[o]=1):e[o]=1},o=function(e,t,s){e._iterateFilteredChildren(t,(t=>![e._edgeHiddenType,e._edgeInvisibleType,e._edgeWeakType].includes(t)),(t=>i(e,t,s)))};for(let e=0;e<this.nodeCount;++e){const t=this.nodes[e*this._nodeFieldCount+this._nodeDetachednessOffset];t!==w.Unknown&&i(this,e,t)}for(;0!==t.length;){o(this,t.pop(),w.Attached)}for(;0!==s.length;){const e=s.pop();this.nodes[e*this._nodeFieldCount+this._nodeDetachednessOffset]!==w.Attached&&o(this,e,w.Detached)}console.timeEnd("propagateDOMState")}_buildSamples(){const t=this._rawSamples;if(!t||!t.length)return;const s=t.length/2,n=new Array(s),i=new Array(s),o=new Array(s),r=this._metaNode.sample_fields.indexOf("timestamp_us"),d=this._metaNode.sample_fields.indexOf("last_assigned_id");for(let e=0;e<s;e++)n[e]=0,i[e]=t[2*e+r]/1e3,o[e]=t[2*e+d];const a=this.nodes.length,h=this._nodeFieldCount,l=this.rootNode();for(let e=0;e<a;e+=h){l.nodeIndex=e;const t=l.id();if(t%2==0)continue;const i=o.lowerBound(t);i!==s&&(n[i]+=l.selfSize())}this._samples=new e.Samples(i,o,n)}_buildLocationMap(){const t=new Map,s=this._locations;for(let n=0;n<s.length;n+=this._locationFieldCount){const i=s[n+this._locationIndexOffset],o=s[n+this._locationScriptIdOffset],r=s[n+this._locationLineOffset],d=s[n+this._locationColumnOffset];t.set(i,new e.Location(o,r,d))}this._locationMap=t}getLocation(e){return this._locationMap.get(e)||null}getSamples(){return this._samples}calculateFlags(){throw new Error("Not implemented")}calculateStatistics(){throw new Error("Not implemented")}userObjectsMapAndFlag(){throw new Error("Not implemented")}calculateSnapshotDiff(t,s){let n=this._snapshotDiffs[t];if(n)return n;n={};const i=this.aggregates(!0,"allObjects");for(const e in s){const t=s[e],o=this._calculateDiffForClass(t,i[e]);o&&(n[e]=o)}const o=new e.AggregateForDiff;for(const e in i){if(e in s)continue;const t=this._calculateDiffForClass(o,i[e]);t&&(n[e]=t)}return this._snapshotDiffs[t]=n,n}_calculateDiffForClass(t,s){const n=t.ids,i=t.indexes,o=t.selfSizes,r=s?s.idxs:[];let d=0,a=0;const h=n.length,l=r.length,_=new e.Diff,c=this.createNode(r[a]);for(;d<h&&a<l;){const e=n[d];e<c.id()?(_.deletedIndexes.push(i[d]),_.removedCount++,_.removedSize+=o[d],++d):e>c.id()?(_.addedIndexes.push(r[a]),_.addedCount++,_.addedSize+=c.selfSize(),c.nodeIndex=r[++a]):(++d,c.nodeIndex=r[++a])}for(;d<h;)_.deletedIndexes.push(i[d]),_.removedCount++,_.removedSize+=o[d],++d;for(;a<l;)_.addedIndexes.push(r[a]),_.addedCount++,_.addedSize+=c.selfSize(),c.nodeIndex=r[++a];return _.countDelta=_.addedCount-_.removedCount,_.sizeDelta=_.addedSize-_.removedSize,_.addedCount||_.removedCount?_:null}_nodeForSnapshotObjectId(e){for(let t=this._allNodes();t.hasNext();t.next())if(t.node.id()===e)return t.node;return null}nodeClassName(e){const t=this._nodeForSnapshotObjectId(e);return t?t.className():null}idsOfObjectsWithName(e){const t=[];for(let s=this._allNodes();s.hasNext();s.next())s.item().name()===e&&t.push(s.item().id());return t}createEdgesProvider(e){const t=this.createNode(e),s=this.containmentEdgesFilter(),n=new c(this);return new C(this,s,t.edges(),n)}createEdgesProviderForTest(e,t){const s=this.createNode(e),n=new c(this);return new C(this,t,s.edges(),n)}retainingEdgesFilter(){return null}containmentEdgesFilter(){return null}createRetainingEdgesProvider(e){const t=this.createNode(e),s=this.retainingEdgesFilter(),n=new u(this);return new C(this,s,t.retainers(),n)}createAddedNodesProvider(e,t){const s=this._snapshotDiffs[e][t];return new E(this,s.addedIndexes)}createDeletedNodesProvider(e){return new E(this,e)}createNodesProviderForClass(e,t){return new E(this,this.aggregatesWithFilter(t)[e].idxs)}_maxJsNodeId(){const e=this._nodeFieldCount,t=this.nodes,s=t.length;let n=0;for(let i=this._nodeIdOffset;i<s;i+=e){const e=t[i];e%2!=0&&(n<e&&(n=e))}return n}updateStaticData(){return new e.StaticData(this.nodeCount,this._rootNodeIndex,this.totalSize,this._maxJsNodeId())}}class O{constructor(e,t){this._iterator=e,this._indexProvider=t,this._isEmpty=!e.hasNext(),this._iterationOrder=null,this._currentComparator=null,this._sortedPrefixLength=0,this._sortedSuffixLength=0}_createIterationOrder(){if(!this._iterationOrder){this._iterationOrder=[];for(let e=this._iterator;e.hasNext();e.next())this._iterationOrder.push(e.item().itemIndex())}}isEmpty(){return this._isEmpty}serializeItemsRange(t,s){if(this._createIterationOrder(),t>s)throw new Error("Start position > end position: "+t+" > "+s);if(!this._iterationOrder)throw new Error("Iteration order undefined");if(s>this._iterationOrder.length&&(s=this._iterationOrder.length),this._sortedPrefixLength<s&&t<this._iterationOrder.length-this._sortedSuffixLength&&this._currentComparator){const e=this._currentComparator;this.sort(e,this._sortedPrefixLength,this._iterationOrder.length-1-this._sortedSuffixLength,t,s-1),t<=this._sortedPrefixLength&&(this._sortedPrefixLength=s),s>=this._iterationOrder.length-this._sortedSuffixLength&&(this._sortedSuffixLength=this._iterationOrder.length-t)}let n=t;const i=s-t,o=new Array(i);for(let e=0;e<i;++e){const t=this._iterationOrder[n++],s=this._indexProvider.itemForIndex(t);o[e]=s.serialize()}return new e.ItemsRange(t,s,this._iterationOrder.length,o)}sortAndRewind(e){this._currentComparator=e,this._sortedPrefixLength=0,this._sortedSuffixLength=0}sort(e,t,s,n,i){throw new Error("Not implemented")}}class C extends O{constructor(e,t,s,n){super(t?new N(s,t):s,n),this.snapshot=e}sort(e,t,s,i,o){const r=e.fieldName1,d=e.fieldName2,a=e.ascending1,h=e.ascending2,l=this._iterator.item().clone(),_=l.clone(),c=this.snapshot.createNode(),u=this.snapshot.createNode();function f(e,t,s){if(l.edgeIndex=t,_.edgeIndex=s,"__proto__"===_.name())return-1;if("__proto__"===l.name())return 1;const n=l.hasStringName()===_.hasStringName()?l.name()<_.name()?-1:l.name()>_.name()?1:0:l.hasStringName()?-1:1;return e?n:-n}function p(e,t,s,n){l.edgeIndex=s,c.nodeIndex=l.nodeIndex();const i=c[e]();_.edgeIndex=n,u.nodeIndex=_.nodeIndex();const o=u[e](),r=i<o?-1:i>o?1:0;return t?r:-r}if(!this._iterationOrder)throw new Error("Iteration order not defined");"!edgeName"===r?n.sortRange(this._iterationOrder,(function(e,t){let s=f(a,e,t);return 0===s&&(s=p(d,h,e,t)),0===s?e-t:s}),t,s,i,o):"!edgeName"===d?n.sortRange(this._iterationOrder,(function(e,t){let s=p(r,a,e,t);return 0===s&&(s=f(h,e,t)),0===s?e-t:s}),t,s,i,o):n.sortRange(this._iterationOrder,(function(e,t){let s=p(r,a,e,t);return 0===s&&(s=p(d,h,e,t)),0===s?e-t:s}),t,s,i,o)}}class E extends O{constructor(e,t){const s=new _(e);super(new I(s,t),s),this.snapshot=e}nodePosition(e){this._createIterationOrder();const t=this.snapshot.createNode();let s=0;if(!this._iterationOrder)throw new Error("Iteration order not defined");for(;s<this._iterationOrder.length&&(t.nodeIndex=this._iterationOrder[s],t.id()!==e);s++);if(s===this._iterationOrder.length)return-1;const n=this._iterationOrder[s];let i=0;const o=this._currentComparator,r=this._buildCompareFunction(o);for(let e=0;e<this._iterationOrder.length;e++)r(this._iterationOrder[e],n)<0&&++i;return i}_buildCompareFunction(e){const t=this.snapshot.createNode(),s=this.snapshot.createNode(),n=t[e.fieldName1],i=t[e.fieldName2],o=e.ascending1?1:-1,r=e.ascending2?1:-1;function d(e,n){const i=e.call(t),o=e.call(s);return i<o?-n:i>o?n:0}return function(e,a){t.nodeIndex=e,s.nodeIndex=a;let h=d(n,o);return 0===h&&(h=d(i,r)),h||e-a}}sort(e,t,s,i,o){if(!this._iterationOrder)throw new Error("Iteration order not defined");n.sortRange(this._iterationOrder,this._buildCompareFunction(e),t,s,i,o)}}class F extends T{constructor(e,t){super(e,t),this._nodeFlags={canBeQueried:1,detachedDOMTreeNode:2,pageObject:4},this._lazyStringCache={},this.initialize(),this._flags}createNode(e){return new b(this,void 0===e?-1:e)}createEdge(e){return new z(this,e)}createRetainingEdge(e){return new v(this,e)}containmentEdgesFilter(){return e=>!e.isInvisible()}retainingEdgesFilter(){const e=this.containmentEdgesFilter();return function(t){return e(t)&&!t.node().isRoot()&&!t.isWeak()}}calculateFlags(){this._flags=new Uint32Array(this.nodeCount),this._markDetachedDOMTreeNodes(),this._markQueriableHeapObjects(),this._markPageOwnedNodes()}calculateDistances(){super.calculateDistances((function(e,t){if(e.isHidden())return"sloppy_function_map"!==t.name()||"system / NativeContext"!==e.rawName();if(e.isArray()){if("(map descriptors)"!==e.rawName())return!0;const s=parseInt(t.name(),10);return s<2||s%3!=1}return!0}))}isUserRoot(e){return e.isUserRoot()||e.isDocumentDOMTreesRoot()}userObjectsMapAndFlag(){return{map:this._flags,flag:this._nodeFlags.pageObject}}_flagsOfNode(e){return this._flags[e.nodeIndex/this._nodeFieldCount]}_markDetachedDOMTreeNodes(){const e=this.nodes,t=e.length,s=this._nodeFieldCount,n=this._nodeNativeType,i=this._nodeTypeOffset,o=this._nodeFlags.detachedDOMTreeNode,r=this.rootNode();for(let d=0,a=0;d<t;d+=s,a++){e[d+i]===n&&(r.nodeIndex=d,r.name().startsWith("Detached ")&&(this._flags[a]|=o))}}_markQueriableHeapObjects(){const e=this._nodeFlags.canBeQueried,t=this._edgeHiddenType,s=this._edgeInternalType,n=this._edgeInvisibleType,i=this._edgeWeakType,o=this._edgeToNodeOffset,r=this._edgeTypeOffset,d=this._edgeFieldsCount,a=this.containmentEdges,h=this._nodeFieldCount,l=this._firstEdgeIndexes,_=this._flags,c=[];for(let e=this.rootNode().edges();e.hasNext();e.next())e.edge.node().isUserRoot()&&c.push(e.edge.node().nodeIndex/h);for(;c.length;){const u=c.pop();if(_[u]&e)continue;_[u]|=e;const f=l[u],p=l[u+1];for(let l=f;l<p;l+=d){const d=a[l+o]/h;if(_[d]&e)continue;const u=a[l+r];u!==t&&u!==n&&u!==s&&u!==i&&c.push(d)}}}_markPageOwnedNodes(){const e=this._edgeShortcutType,t=this._edgeElementType,s=this._edgeToNodeOffset,n=this._edgeTypeOffset,i=this._edgeFieldsCount,o=this._edgeWeakType,r=this._firstEdgeIndexes,d=this.containmentEdges,a=this._nodeFieldCount,h=this.nodeCount,l=this._flags,_=this._nodeFlags.pageObject,c=new Uint32Array(h);let u=0;const f=this._rootNodeIndex/a,p=this.rootNode();for(let o=r[f],h=r[f+1];o<h;o+=i){const i=d[o+n],r=d[o+s];if(i===t){if(p.nodeIndex=r,!p.isDocumentDOMTreesRoot())continue}else if(i!==e)continue;const h=r/a;c[u++]=h,l[h]|=_}for(;u;){const e=c[--u],t=r[e],h=r[e+1];for(let e=t;e<h;e+=i){const t=d[e+s]/a;if(l[t]&_)continue;d[e+n]!==o&&(c[u++]=t,l[t]|=_)}}}calculateStatistics(){const t=this._nodeFieldCount,s=this.nodes,n=s.length,i=this._nodeTypeOffset,o=this._nodeSelfSizeOffset,r=this._nodeNativeType,d=this._nodeCodeType,a=this._nodeConsStringType,h=this._nodeSlicedStringType,l=this._nodeDistances;let _=0,c=0,u=0,f=0,p=0;const g=this.rootNode();for(let m=0;m<n;m+=t){const n=s[m+o];if(l[m/t]>=e.baseSystemDistance){p+=n;continue}const x=s[m+i];g.nodeIndex=m,x===r?_+=n:x===d?c+=n:x===a||x===h||"string"===g.type()?u+=n:"Array"===g.name()&&(f+=this._calculateArraySize(g))}this._statistics=new e.Statistics,this._statistics.total=this.totalSize,this._statistics.v8heap=this.totalSize-_,this._statistics.native=_,this._statistics.code=c,this._statistics.jsArrays=f,this._statistics.strings=u,this._statistics.system=p}_calculateArraySize(e){let t=e.selfSize();const s=e.edgeIndexesStart(),n=e.edgeIndexesEnd(),i=this.containmentEdges,o=this.strings,r=this._edgeToNodeOffset,d=this._edgeTypeOffset,a=this._edgeNameOffset,h=this._edgeFieldsCount,l=this._edgeInternalType;for(let _=s;_<n;_+=h){if(i[_+d]!==l)continue;if("elements"!==o[i[_+a]])continue;const s=i[_+r];e.nodeIndex=s,1===e.retainersCount()&&(t+=e.selfSize());break}return t}getStatistics(){return this._statistics}}class b extends m{constructor(e,t){super(e,t)}canBeQueried(){const e=this._snapshot,t=e._flagsOfNode(this);return Boolean(t&e._nodeFlags.canBeQueried)}rawName(){return super.name()}name(){const e=this._snapshot;if(this.rawType()===e._nodeConsStringType){let t=e._lazyStringCache[this.nodeIndex];return void 0===t&&(t=this._consStringName(),e._lazyStringCache[this.nodeIndex]=t),t}return this.rawName()}_consStringName(){const e=this._snapshot,t=e._nodeConsStringType,s=e._edgeInternalType,n=e._edgeFieldsCount,i=e._edgeToNodeOffset,o=e._edgeTypeOffset,r=e._edgeNameOffset,d=e.strings,a=e.containmentEdges,h=e._firstEdgeIndexes,l=e._nodeFieldCount,_=e._nodeTypeOffset,c=e._nodeNameOffset,u=e.nodes,f=[];f.push(this.nodeIndex);let p="";for(;f.length&&p.length<1024;){const e=f.pop();if(u[e+_]!==t){p+=d[u[e+c]];continue}const g=e/l,m=h[g],x=h[g+1];let I=0,N=0;for(let e=m;e<x&&(!I||!N);e+=n){if(a[e+o]===s){const t=d[a[e+r]];"first"===t?I=a[e+i]:"second"===t&&(N=a[e+i])}}f.push(N),f.push(I)}return p}className(){const e=this.type();switch(e){case"hidden":return"(system)";case"object":case"native":return this.name();case"code":return"(compiled code)";default:return"("+e+")"}}classIndex(){const e=this._snapshot,t=e.nodes,s=t[this.nodeIndex+e._nodeTypeOffset];return s===e._nodeObjectType||s===e._nodeNativeType?t[this.nodeIndex+e._nodeNameOffset]:-1-s}id(){const e=this._snapshot;return e.nodes[this.nodeIndex+e._nodeIdOffset]}isHidden(){return this.rawType()===this._snapshot._nodeHiddenType}isArray(){return this.rawType()===this._snapshot._nodeArrayType}isSynthetic(){return this.rawType()===this._snapshot._nodeSyntheticType}isUserRoot(){return!this.isSynthetic()}isDocumentDOMTreesRoot(){return this.isSynthetic()&&"(Document DOM trees)"===this.name()}serialize(){const e=super.serialize(),t=this._snapshot,s=t._flagsOfNode(this);return s&t._nodeFlags.canBeQueried&&(e.canBeQueried=!0),s&t._nodeFlags.detachedDOMTreeNode&&(e.detachedDOMTreeNode=!0),e}}class z extends l{constructor(e,t){super(e,t)}clone(){const e=this._snapshot;return new z(e,this.edgeIndex)}hasStringName(){return this.isShortcut()?isNaN(parseInt(this._name(),10)):this._hasStringName()}isElement(){return this.rawType()===this._snapshot._edgeElementType}isHidden(){return this.rawType()===this._snapshot._edgeHiddenType}isWeak(){return this.rawType()===this._snapshot._edgeWeakType}isInternal(){return this.rawType()===this._snapshot._edgeInternalType}isInvisible(){return this.rawType()===this._snapshot._edgeInvisibleType}isShortcut(){return this.rawType()===this._snapshot._edgeShortcutType}name(){const e=this._name();if(!this.isShortcut())return String(e);const t=parseInt(e,10);return String(isNaN(t)?e:t)}toString(){const e=this.name();switch(this.type()){case"context":return"->"+e;case"element":return"["+e+"]";case"weak":return"[["+e+"]]";case"property":return-1===e.indexOf(" ")?"."+e:'["'+e+'"]';case"shortcut":return"string"==typeof e?-1===e.indexOf(" ")?"."+e:'["'+e+'"]':"["+e+"]";case"internal":case"hidden":case"invisible":return"{"+e+"}"}return"?"+e+"?"}_hasStringName(){const e=this.rawType(),t=this._snapshot;return e!==t._edgeElementType&&e!==t._edgeHiddenType}_name(){return this._hasStringName()?this._snapshot.strings[this._nameOrIndex()]:this._nameOrIndex()}_nameOrIndex(){return this._edges[this.edgeIndex+this._snapshot._edgeNameOffset]}rawType(){return this._edges[this.edgeIndex+this._snapshot._edgeTypeOffset]}}class v extends p{constructor(e,t){super(e,t)}clone(){const e=this._snapshot;return new v(e,this.retainerIndex())}isHidden(){return this._edge().isHidden()}isInternal(){return this._edge().isInternal()}isInvisible(){return this._edge().isInvisible()}isShortcut(){return this._edge().isShortcut()}isWeak(){return this._edge().isWeak()}}var A=Object.freeze({__proto__:null,HeapSnapshotItem:class{itemIndex(){throw new Error("Not implemented")}serialize(){throw new Error("Not implemented")}},HeapSnapshotEdge:l,HeapSnapshotItemIterator:class{hasNext(){throw new Error("Not implemented")}item(){throw new Error("Not implemented")}next(){throw new Error("Not implemented")}},HeapSnapshotItemIndexProvider:class{itemForIndex(e){throw new Error("Not implemented")}},HeapSnapshotNodeIndexProvider:_,HeapSnapshotEdgeIndexProvider:c,HeapSnapshotRetainerEdgeIndexProvider:u,HeapSnapshotEdgeIterator:f,HeapSnapshotRetainerEdge:p,HeapSnapshotRetainerEdgeIterator:g,HeapSnapshotNode:m,HeapSnapshotNodeIterator:x,HeapSnapshotIndexRangeIterator:I,HeapSnapshotFilteredIterator:N,HeapSnapshotProgress:y,HeapSnapshotProblemReport:S,Profile:undefined,HeapSnapshot:T,HeapSnapshotHeader:class{constructor(){this.title="",this.meta=new class{constructor(){this.location_fields=[],this.node_fields=[],this.node_types=[],this.edge_fields=[],this.edge_types=[],this.trace_function_info_fields=[],this.trace_node_fields=[],this.sample_fields=[],this.type_strings={}}},this.node_count=0,this.edge_count=0,this.trace_function_count=0,this.root_index=0}},HeapSnapshotItemProvider:O,HeapSnapshotEdgesProvider:C,HeapSnapshotNodesProvider:E,JSHeapSnapshot:F,JSHeapSnapshotNode:b,JSHeapSnapshotEdge:z,JSHeapSnapshotRetainerEdge:v,AggregatedInfo:undefined});var D=Object.freeze({__proto__:null,HeapSnapshotLoader:class{constructor(e){this._reset(),this._progress=new y(e),this._buffer="",this._dataCallback=null,this._done=!1,this._parseInput(),this._snapshot,this._array,this._arrayIndex}dispose(){this._reset()}_reset(){this._json="",this._snapshot=void 0}close(){this._done=!0,this._dataCallback&&this._dataCallback("")}buildSnapshot(){this._snapshot=this._snapshot||{},this._progress.updateStatus(s`Processing snapshot…`);const e=new F(this._snapshot,this._progress);return this._reset(),e}_parseUintArray(){let e=0;const t="0".charCodeAt(0),s="9".charCodeAt(0),n="]".charCodeAt(0),i=this._json.length;for(;;){for(;e<i;){const i=this._json.charCodeAt(e);if(t<=i&&i<=s)break;if(i===n)return this._json=this._json.slice(e+1),!1;++e}if(e===i)return this._json="",!0;let o=0;const r=e;for(;e<i;){const n=this._json.charCodeAt(e);if(t>n||n>s)break;o*=10,o+=n-t,++e}if(e===i)return this._json=this._json.slice(r),!0;if(!this._array)throw new Error("Array not instantiated");this._array[this._arrayIndex++]=o}}_parseStringsArray(){this._progress.updateStatus(s`Parsing strings…`);const e=this._json.lastIndexOf("]");if(-1===e)throw new Error("Incomplete JSON");if(this._json=this._json.slice(0,e+1),!this._snapshot)throw new Error("No snapshot in parseStringsArray");this._snapshot.strings=JSON.parse(this._json)}write(e){this._buffer+=e,this._dataCallback&&(this._dataCallback(this._buffer),this._dataCallback=null,this._buffer="")}_fetchChunk(){return this._done?Promise.resolve(this._buffer):new Promise((e=>{this._dataCallback=e}))}async _findToken(e,t){for(;;){const s=this._json.indexOf(e,t||0);if(-1!==s)return s;t=this._json.length-e.length+1,this._json+=await this._fetchChunk()}}async _parseArray(e,t,s){const n=await this._findToken(e),i=await this._findToken("[",n);for(this._json=this._json.slice(i+1),this._array=s?new Uint32Array(s):[],this._arrayIndex=0;this._parseUintArray();)this._progress.updateProgress(t,this._arrayIndex,this._array.length),this._json+=await this._fetchChunk();const o=this._array;return this._array=null,o}async _parseInput(){const e='"snapshot"',t=await this._findToken(e);if(-1===t)throw new Error("Snapshot token not found");this._progress.updateStatus(s`Loading snapshot info…`);const n=this._json.slice(t+e.length+1);for(this._jsonTokenizer=new i.BalancedJSONTokenizer((e=>{this._json=this._jsonTokenizer.remainder(),this._jsonTokenizer=null,this._snapshot=this._snapshot||{},this._snapshot.snapshot=JSON.parse(e)})),this._jsonTokenizer.write(n);this._jsonTokenizer;)this._jsonTokenizer.write(await this._fetchChunk());this._snapshot=this._snapshot||{};const o=await this._parseArray('"nodes"',s`Loading nodes… %d%%`,this._snapshot.snapshot.meta.node_fields.length*this._snapshot.snapshot.node_count);this._snapshot.nodes=o;const r=await this._parseArray('"edges"',s`Loading edges… %d%%`,this._snapshot.snapshot.meta.edge_fields.length*this._snapshot.snapshot.edge_count);if(this._snapshot.edges=r,this._snapshot.snapshot.trace_function_count){const e=await this._parseArray('"trace_function_infos"',s`Loading allocation traces… %d%%`,this._snapshot.snapshot.meta.trace_function_info_fields.length*this._snapshot.snapshot.trace_function_count);this._snapshot.trace_function_infos=e;const t=await this._findToken(":"),n=await this._findToken('"',t),i=this._json.indexOf("["),o=this._json.lastIndexOf("]",n);this._snapshot.trace_tree=JSON.parse(this._json.substring(i,o+1)),this._json=this._json.slice(o+1)}if(this._snapshot.snapshot.meta.sample_fields){const e=await this._parseArray('"samples"',s`Loading samples…`);this._snapshot.samples=e}if(this._snapshot.snapshot.meta.location_fields){const e=await this._parseArray('"locations"',s`Loading locations…`);this._snapshot.locations=e}else this._snapshot.locations=[];this._progress.updateStatus(s`Loading strings…`);const d=await this._findToken('"strings"'),a=await this._findToken("[",d);for(this._json=this._json.slice(a);!this._done;)this._json+=await this._fetchChunk();this._parseStringsArray()}}});var k=Object.freeze({__proto__:null,HeapSnapshotWorkerDispatcher:class{constructor(e,t){this._objects=[],this._global=e,this._postMessage=t}_findFunction(e){const t=e.split(".");let s=this._global;for(let e=0;e<t.length;++e)s=s[t[e]];return s}sendEvent(e,t){this._postMessage({eventName:e,data:t})}dispatchMessage({data:e}){const t={callId:e.callId,result:null,error:void 0,errorCallStack:void 0,errorMethodName:void 0};try{switch(e.disposition){case"create":{const t=this._findFunction(e.methodName);this._objects[e.objectId]=new t(this);break}case"dispose":delete this._objects[e.objectId];break;case"getter":{const s=this._objects[e.objectId][e.methodName];t.result=s;break}case"factory":{const s=this._objects[e.objectId],n=s[e.methodName].apply(s,e.methodArguments);n&&(this._objects[e.newObjectId]=n),t.result=Boolean(n);break}case"method":{const s=this._objects[e.objectId];t.result=s[e.methodName].apply(s,e.methodArguments);break}case"evaluateForTest":try{t.result=self.eval(e.source)}catch(e){t.result=e.toString()}}}catch(s){t.error=s.toString(),t.errorCallStack=s.stack,e.methodName&&(t.errorMethodName=e.methodName)}this._postMessage(t)}}});export{h as AllocationProfile,A as HeapSnapshot,D as HeapSnapshotLoader,k as HeapSnapshotWorkerDispatcher};
